/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.wireless.qa.mobileharness.shared.api.device;

import static com.google.common.base.Preconditions.checkState;
import static com.google.common.collect.ImmutableListMultimap.toImmutableListMultimap;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Ascii;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.flogger.FluentLogger;
import com.google.common.util.concurrent.MoreExecutors;
import com.google.devtools.mobileharness.api.model.error.ExtErrorId;
import com.google.devtools.mobileharness.api.model.error.MobileHarnessException;
import com.google.devtools.mobileharness.api.model.proto.Device.PostTestDeviceOp;
import com.google.devtools.mobileharness.api.model.proto.Test.TestResult;
import com.google.devtools.mobileharness.infra.container.annotation.ProcessIncompatible;
import com.google.devtools.mobileharness.infra.controller.device.config.ApiConfig;
import com.google.devtools.mobileharness.platform.android.systemspec.AndroidSystemSpecUtil;
import com.google.devtools.mobileharness.platform.testbed.TestbedUtil;
import com.google.devtools.mobileharness.platform.testbed.adhoc.AdhocTestbedConfig;
import com.google.devtools.mobileharness.platform.testbed.config.GlobalTestbedLoader;
import com.google.devtools.mobileharness.platform.testbed.config.SubDeviceInfo;
import com.google.devtools.mobileharness.platform.testbed.config.SubDeviceKey;
import com.google.devtools.mobileharness.platform.testbed.config.TestbedConfig;
import com.google.devtools.mobileharness.platform.testbed.config.TestbedLoader;
import com.google.devtools.mobileharness.shared.util.concurrent.ConcurrencyUtil;
import com.google.devtools.mobileharness.shared.util.concurrent.ConcurrencyUtil.SubTask;
import com.google.errorprone.annotations.Keep;
import com.google.wireless.qa.mobileharness.shared.api.spec.TestbedDeviceSpec;
import com.google.wireless.qa.mobileharness.shared.constant.Dimension.Name;
import com.google.wireless.qa.mobileharness.shared.constant.Dimension.Value;
import com.google.wireless.qa.mobileharness.shared.model.job.TestInfo;
import com.google.wireless.qa.mobileharness.shared.proto.Common.StrPair;
import com.google.wireless.qa.mobileharness.shared.proto.Device.SubDeviceDimensions;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

/** A generic testbed definition that can be composed of multiple devices. */
@ProcessIncompatible("deviceFactory")
public class TestbedDevice extends BaseDevice implements CompositeDevice {

  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  /** Applied to a testbed that matches the configs exactly. */
  public static final String NORMAL_TESTBED_DEVICE_NAME = "NormalTestbedDevice";

  /**
   * If a testbed can be detected, but the sub-devices are in an unexpected state, then it will be
   * abnormal. This usually indicates that a sub-device exists but does not contain the right alias.
   */
  public static final String ABNORMAL_TESTBED_DEVICE_NAME = "AbnormalTestbedDevice";

  private static final String ANDROID_MORETO_DRIVER = "AndroidMoreto";

  // Those dimension are generated by MH for the purpose of device management, hence they should not
  // be overridden.
  private static final ImmutableSet<String> NOT_OVERRIDE_DIMENSIONS =
      ImmutableSet.of(
          Ascii.toLowerCase(Name.CONTROL_ID.name()),
          Ascii.toLowerCase(Name.ID.name()),
          Ascii.toLowerCase(Name.UUID.name()),
          Ascii.toLowerCase(Name.UUID_VOLATILE.name()),
          Ascii.toLowerCase(Name.SUPPORTS_ADHOC.name()),
          Ascii.toLowerCase(Name.LAB_SUPPORTS_CONTAINER.name()),
          Ascii.toLowerCase(Name.DEVICE_SUPPORTS_CONTAINER.name()),
          Ascii.toLowerCase(Name.LAB_SUPPORTS_SANDBOX.name()),
          Ascii.toLowerCase(Name.DEVICE_SUPPORTS_SANDBOX.name()),
          Ascii.toLowerCase(Name.SCREENSHOT_ABLE.name()));

  /**
   * Device ID -> Post run test result. This is used to track which sub-devices should be rebooted
   * with calls to {@link #reboot()}.
   */
  private final Map<String, PostTestDeviceOp> rebootState;

  private final AtomicInteger deviceConsecutiveTestWithoutRebootCount;

  private final AtomicInteger deviceConsecutiveFailWithoutRebootCount;

  private final DeviceFactory deviceFactory;
  private final ExecutorService subdeviceExecutor;
  private final List<Device> managedDevices;
  private final TestbedLoader testbedLoader;
  private final AtomicReference<TestbedConfig> config;
  private final ApiConfig apiConfig;
  @Nullable private final ImmutableList<Device> preCreatedSubDevices;

  /**
   * Creates a static testbed using the default (global) testbed config loader.
   *
   * @param deviceId The id of the testbed.
   * @throws MobileHarnessException Thrown if the testbed could not be loaded.
   */
  @Keep
  public TestbedDevice(String deviceId) throws MobileHarnessException {
    this(deviceId, GlobalTestbedLoader.getInstance());
  }

  /**
   * Creates a dynamic testbed for an adhoc testbed test.
   *
   * @param deviceId The id of the testbed.
   * @param preCreatedSubDevices pre-created sub device instances from MH device manager. If
   *     specified, this testbed device will not create sub device instances anymore.
   * @throws MobileHarnessException Thrown if the testbed could not be loaded.
   */
  public TestbedDevice(String deviceId, List<Device> preCreatedSubDevices)
      throws MobileHarnessException {
    this(
        deviceId,
        () -> ImmutableMap.of(deviceId, AdhocTestbedConfig.create(deviceId, preCreatedSubDevices)),
        preCreatedSubDevices,
        new DeviceFactory(),
        /* apiConfig= */ null,
        /* managedDeviceInfo= */ false);
  }

  /** Same as {@link TestbedDevice(String, List)} with a specific ApiConfig. */
  @VisibleForTesting
  TestbedDevice(String deviceId, List<Device> preCreatedSubDevices, ApiConfig apiConfig)
      throws MobileHarnessException {
    this(
        deviceId,
        () -> ImmutableMap.of(deviceId, AdhocTestbedConfig.create(deviceId, preCreatedSubDevices)),
        preCreatedSubDevices,
        new DeviceFactory(),
        apiConfig,
        /* managedDeviceInfo= */ false);
  }

  /**
   * Creates a static testbed.
   *
   * @param deviceId The id of the testbed.
   * @param testbedLoader The testbed loader to use to load the testbeds config.
   * @throws MobileHarnessException Thrown if the testbed could not be loaded.
   */
  @VisibleForTesting
  public TestbedDevice(String deviceId, TestbedLoader testbedLoader) throws MobileHarnessException {
    this(
        deviceId,
        testbedLoader,
        /* preCreatedSubDevices= */ null,
        new DeviceFactory(),
        /* apiConfig= */ null,
        /* managedDeviceInfo= */ true);
  }

  /**
   * Creates a testbed from a config loader for testing.
   *
   * @param deviceId The id of the testbed
   * @param testbedLoader The TestbedLoader to load configs from
   * @param preCreatedSubDevices A (potentially null) list of already created device objects
   * @param deviceFactory A DeviceFactory for instantiating device objects
   */
  @VisibleForTesting
  TestbedDevice(
      String deviceId,
      TestbedLoader testbedLoader,
      @Nullable List<Device> preCreatedSubDevices,
      DeviceFactory deviceFactory,
      @Nullable ApiConfig apiConfig,
      boolean managedDeviceInfo)
      throws MobileHarnessException {
    super(deviceId, managedDeviceInfo);
    this.testbedLoader = testbedLoader;
    this.config = new AtomicReference<>(testbedLoader.getTestbedConfigs().get(deviceId));
    this.deviceFactory = deviceFactory;
    this.managedDevices = new ArrayList<>();
    this.preCreatedSubDevices =
        preCreatedSubDevices == null ? null : ImmutableList.copyOf(preCreatedSubDevices);
    this.subdeviceExecutor = Executors.newCachedThreadPool();
    this.apiConfig = apiConfig == null ? ApiConfig.getInstance() : apiConfig;
    this.rebootState = new ConcurrentHashMap<>();
    this.deviceConsecutiveTestWithoutRebootCount = new AtomicInteger(0);
    this.deviceConsecutiveFailWithoutRebootCount = new AtomicInteger(0);
  }

  public TestbedConfig getConfig() {
    return config.get();
  }

  /**
   * Get a set of all devices managed by this testbed.
   *
   * @return The set of managed devices.
   */
  @Override
  public ImmutableSet<Device> getManagedDevices() {
    return ImmutableSet.copyOf(managedDevices);
  }

  @Override
  public void setUp() throws MobileHarnessException, InterruptedException {
    super.setUp();
    logger.atInfo().log("Setting up TestbedDevice: %s", getDeviceId());

    addManagedConfigDevices();

    setUpSubDevices();

    updateDimensionsAndState();

    addSupportedDriver("NoOpDriver");
    addSupportedDriver("MoblyTest");
    addSupportedDriver("MoblyAospTest");

    addSupportedDecorator("NoOpDecorator");
    addSupportedDecorator("CompositeDeviceDecoratorAdapter");
    addSupportedDecorator("MoblyDecoratorAdapter");
    addSupportedDecorator("TestbedDecoratorAdapter");
  }

  @Override
  public boolean isPrepping() {
    for (Device device : managedDevices) {
      if (device.isPrepping()) {
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if there are any changes to the testbeds subdevices. If any device reports a change,
   * then the testbed will report one as well and re-calculate its shared dimensions.
   */
  @Override
  public boolean checkDevice() throws MobileHarnessException, InterruptedException {
    try {
      boolean isUpdate =
          forEachManagedDevice(
              Device::checkDevice,
              results -> results.stream().anyMatch(result -> result != null && result),
              "checkDevice()");
      // Check the config for changes.
      isUpdate |= checkConfig();
      if (isUpdate) {
        updateManagedDevices();
        updateDimensionsAndState();
      }
      return isUpdate;
    } catch (MobileHarnessException e) {
      throw new MobileHarnessException(
          ExtErrorId.MOBLY_TESTBED_CHECK_DEVICE_ERROR, "Failed to check device", e);
    }
  }

  /**
   * Checks if there are any changes to the testbed's underlying config, if this config was loaded
   * from file. If there is any change (as determined by changes to attributes defined by the
   * TestbedConfig interface), then the config will be reloaded and return true (otherwise false).
   *
   * @throws MobileHarnessException Thrown if the testbed was renamed or the config disappeared.
   */
  private boolean checkConfig() throws MobileHarnessException {
    TestbedConfig newConfig = testbedLoader.getTestbedConfigs().get(getDeviceId());
    if (newConfig == null) {
      throw new MobileHarnessException(
          ExtErrorId.MOBLY_TESTBED_PARSING_ERROR, "Device " + getDeviceId() + " no longer exists.");
    }
    return !newConfig.equals(config.getAndSet(newConfig));
  }

  @Override
  public void preRunTest(TestInfo testInfo) throws MobileHarnessException, InterruptedException {
    try {
      forEachManagedDevice(
          device -> device.preRunTest(testInfo),
          String.format("preRunTest(%s))", getTestInfoLogString(testInfo)));
    } catch (MobileHarnessException e) {
      throw new MobileHarnessException(
          ExtErrorId.MOBLY_TESTBED_PRE_RUN_TEST_ERROR, "Failed to pre run test", e);
    }
  }

  @Override
  public PostTestDeviceOp postRunTest(TestInfo testInfo)
      throws MobileHarnessException, InterruptedException {
    if (preCreatedSubDevices == null) {
      testInfo
          .log()
          .atInfo()
          .alsoTo(logger)
          .log(
              "Updating serialized sub-device dimensions for static testbed device '%s'",
              getDeviceId());
      applySerializedSubDeviceDimensions();
    }
    TestResult testResult = testInfo.resultWithCause().get().type();
    if (TestResult.PASS.equals(testResult) || TestResult.SKIP.equals(testResult)) {
      deviceConsecutiveFailWithoutRebootCount.set(0);
    } else {
      deviceConsecutiveFailWithoutRebootCount.incrementAndGet();
    }
    deviceConsecutiveTestWithoutRebootCount.incrementAndGet();
    try {
      return forEachManagedDevice(
          device -> {
            PostTestDeviceOp postRunResult = device.postRunTest(testInfo);
            String deviceId = device.getDeviceId();
            rebootState.put(deviceId, postRunResult);
            return postRunResult;
          },
          postRunTestOps -> {
            return postRunTestOps.stream().anyMatch(PostTestDeviceOp.REBOOT::equals)
                ? PostTestDeviceOp.REBOOT
                : PostTestDeviceOp.NONE;
          },
          String.format("postRunTest(%s)", getTestInfoLogString(testInfo)));
    } catch (MobileHarnessException e) {
      throw new MobileHarnessException(
          ExtErrorId.MOBLY_TESTBED_POST_RUN_TEST_ERROR, "Failed to post run test", e);
    }
  }

  @Override
  public void reboot() throws MobileHarnessException, InterruptedException {
    AtomicBoolean subDeviceRebooted = new AtomicBoolean(false);
    SubdeviceConsumer rebootConsumer =
        device -> {
          if (shouldRebootSubDevice(device)) {
            logger.atInfo().log("Rebooting subdevice: %s", device.getDeviceId());
            subDeviceRebooted.set(true);
            device.reboot();
          }
        };

    try {
      // This might be called after {@link Device#tearDown} so make sure the executor hasn't been
      // shutdown yet.
      if (subdeviceExecutor != null
          && !subdeviceExecutor.isShutdown()
          && !subdeviceExecutor.isTerminated()) {
        forEachManagedDevice(rebootConsumer, "reboot()");
      } else {
        for (Device device : managedDevices) {
          rebootConsumer.run(device);
        }
      }
    } catch (MobileHarnessException e) {
      throw new MobileHarnessException(
          ExtErrorId.MOBLY_TESTBED_REBOOT_ERROR, "Failed to reboot", e);
    }
    if (subDeviceRebooted.get()) {
      deviceConsecutiveTestWithoutRebootCount.set(0);
      deviceConsecutiveFailWithoutRebootCount.set(0);
    }
    rebootState.clear();
  }

  private boolean shouldRebootSubDevice(Device device) throws InterruptedException {
    String deviceId = device.getDeviceId();
    return device.canReboot()
        && (rebootState
                .getOrDefault(deviceId, PostTestDeviceOp.REBOOT)
                .equals(PostTestDeviceOp.REBOOT)
            || checkDeviceConsecutiveRunWithoutRebootCountWithConfig(device));
  }

  /**
   * Return {@code true} if the device consecutive test without reboot count or the device
   * consecutive fail without reboot count is equal or larger than the config value for the testbed.
   */
  private boolean checkDeviceConsecutiveRunWithoutRebootCountWithConfig(Device subDevice) {
    String testbedDeviceControlId = getDeviceControlId();
    String subDeviceId = subDevice.getDeviceId();
    int maxConsecutiveFail = apiConfig.getMaxConsecutiveFail(testbedDeviceControlId);
    logger.atInfo().log(
        "SubDevice %s consecutive fail without reboot count = %d, max consecutive fail = %d",
        subDeviceId, deviceConsecutiveFailWithoutRebootCount.get(), maxConsecutiveFail);
    if (deviceConsecutiveFailWithoutRebootCount.get() >= maxConsecutiveFail) {
      return true;
    }

    int maxConsecutiveTest = apiConfig.getMaxConsecutiveTest(testbedDeviceControlId);
    logger.atInfo().log(
        "SubDevice %s consecutive test without reboot count = %d, max consecutive test = %d",
        subDeviceId, deviceConsecutiveTestWithoutRebootCount.get(), maxConsecutiveTest);
    if (deviceConsecutiveTestWithoutRebootCount.get() >= maxConsecutiveTest) {
      return true;
    }
    return false;
  }

  @Override
  public void tearDown() throws MobileHarnessException, InterruptedException {
    try {
      forEachManagedDevice(Device::tearDown, "tearDown()");
      subdeviceExecutor.shutdown();
    } catch (MobileHarnessException e) {
      throw new MobileHarnessException(
          ExtErrorId.MOBLY_TESTBED_TEAR_DOWN_ERROR, "Failed to teardown", e);
    }
  }

  @Override
  public boolean canReboot() throws InterruptedException {
    for (Device device : managedDevices) {
      if (device.canReboot()) {
        return true;
      }
    }
    return false;
  }

  /**
   * Create a managed device from info about a sub device.
   *
   * @param info The info to create the managed device from.
   * @return The newly created device.
   * @throws MobileHarnessException If the device could not be created.
   */
  private Device createManagedDevice(SubDeviceInfo info) throws MobileHarnessException {
    Class<? extends Device> deviceClass = info.getDeviceType();
    if (deviceClass.equals(AndroidDevice.class)) {
      deviceClass =
          AndroidSystemSpecUtil.isAndroidEmulator(info.getId())
              ? AndroidLocalEmulator.class
              : AndroidRealDevice.class;
    }
    return deviceFactory.createDevice(deviceClass, info.getId());
  }

  /**
   * Sets up all sub devices.
   *
   * @throws MobileHarnessException Thrown if the devices could not be setup.
   * @throws InterruptedException Thrown if setup was interrupted.
   */
  private void setUpSubDevices() throws MobileHarnessException, InterruptedException {
    if (preCreatedSubDevices == null) {
      try {
        forEachManagedDevice(Device::setUp, "setUp()");
      } catch (MobileHarnessException e) {
        throw new MobileHarnessException(
            ExtErrorId.MOBLY_TESTBED_SET_UP_ERROR, "Failed to check device", e);
      }
    }
  }

  private void updateSubDeviceDeviceTypeDimension()
      throws MobileHarnessException, InterruptedException {
    // Do not update sub device dimensions if it is a adhoc testbed.
    if (preCreatedSubDevices != null) {
      return;
    }
    forEachManagedDevice(
        device -> {
          device.updateDimension(
              TestbedDeviceSpec.MH_DEVICE_TYPE_KEY, device.getDeviceTypes().toArray(new String[0]));
        },
        "updateSubDeviceDeviceTypeDimension()");
  }

  private void updateSubDeviceInfoFromConfig() throws MobileHarnessException {
    // Do not update sub device dimensions from sub device info if it is a adhoc testbed. The sub
    // device info in this case is created from the devices anyway.
    if (preCreatedSubDevices != null) {
      return;
    }
    for (Device device : managedDevices) {
      SubDeviceInfo subDeviceInfo = getSubDeviceInfo(device);
      for (String key : subDeviceInfo.getDimensions().keySet()) {
        device.updateDimension(key, subDeviceInfo.getDimensions().get(key).toArray(new String[0]));
      }
      for (Map.Entry<String, ?> entry : subDeviceInfo.getProperties().entrySet()) {
        device.setProperty(entry.getKey(), entry.getValue().toString());
      }
    }
  }

  /**
   * Add all sub devices from the given config.
   *
   * @throws MobileHarnessException Thrown if devices could not be added.
   */
  private void addManagedConfigDevices() throws MobileHarnessException {
    ImmutableList<SubDeviceInfo> subDeviceInfos = getConfig().getDevices().values().asList();
    checkState(
        preCreatedSubDevices == null || subDeviceInfos.size() == preCreatedSubDevices.size(),
        "Testbed config has %s sub devices but there are %s pre-created sub devices",
        subDeviceInfos.size(),
        preCreatedSubDevices == null ? 0 : preCreatedSubDevices.size());
    for (int i = 0; i < subDeviceInfos.size(); i++) {
      managedDevices.add(
          preCreatedSubDevices == null
              ? createManagedDevice(subDeviceInfos.get(i))
              : preCreatedSubDevices.get(i));
    }
  }

  private void updateManagedDevices() throws MobileHarnessException, InterruptedException {
    Map<String, Device> existingDevices = new HashMap<>();
    for (Device device : managedDevices) {
      existingDevices.put(device.getDeviceId(), device);
    }

    // Get the correct and up to date device IDs and info from the test bed config
    Map<String, SubDeviceInfo> configInfo = new LinkedHashMap<>();
    for (SubDeviceInfo subDeviceInfo : getConfig().getDevices().values()) {
      configInfo.put(subDeviceInfo.getId(), subDeviceInfo);
    }

    List<Device> devicesToSetUp = new ArrayList<>();
    List<Device> devicesToTearDown = new ArrayList<>();

    // Create new managed devices or reuse existing ones.
    List<Device> newManagedDevices = new ArrayList<>();
    for (String deviceId : configInfo.keySet()) {
      if (existingDevices.containsKey(deviceId)) {
        newManagedDevices.add(existingDevices.get(deviceId));
      } else {
        Device addedDevice = createManagedDevice(configInfo.get(deviceId));
        newManagedDevices.add(addedDevice);
        devicesToSetUp.add(addedDevice);
      }
    }

    // Teardown no longer referenced devices
    for (String oldDeviceId : existingDevices.keySet()) {
      if (!configInfo.containsKey(oldDeviceId)) {
        devicesToTearDown.add(existingDevices.get(oldDeviceId));
      }
    }

    parallelForEachDevice(devicesToSetUp, Device::setUp, "updateManagedDevices()");
    parallelForEachDevice(devicesToTearDown, Device::tearDown, "updateManagedDevices()");

    managedDevices.clear();
    managedDevices.addAll(newManagedDevices);
  }

  /**
   * Retrieves shared dimensions from subdevices and from config and merge them. Config dimensions
   * override shared device dimensions.
   *
   * @return ImmutableListMultimap of merged config and shared device dimensions.
   */
  private ImmutableListMultimap<String, String> getNewConfigAndSharedDeviceDimensions() {
    Set<StrPair> sharedDeviceAndConfigDimensions = new HashSet<>();
    for (int i = 0; i < managedDevices.size(); i++) {
      Device device = managedDevices.get(i);
      if (device instanceof MiscTestbedSubDevice) {
        continue;
      }
      if (i > 0) {
        sharedDeviceAndConfigDimensions.retainAll(device.getDimensions());
      } else {
        sharedDeviceAndConfigDimensions.addAll(device.getDimensions());
      }
    }

    getConfig().getDimensions().entries().stream()
        .filter(dimension -> !NOT_OVERRIDE_DIMENSIONS.contains(dimension.getKey()))
        .forEach(
            dimension ->
                sharedDeviceAndConfigDimensions.add(
                    StrPair.newBuilder()
                        .setName(dimension.getKey())
                        .setValue(dimension.getValue())
                        .build()));

    return sharedDeviceAndConfigDimensions.stream()
        .filter(dimension -> !NOT_OVERRIDE_DIMENSIONS.contains(dimension.getName()))
        .collect(toImmutableListMultimap(StrPair::getName, StrPair::getValue));
  }

  /**
   * Refreshes dimensions with the dimensions from testbed config and subdevices.
   *
   * <p>The testbed config dimensions and shared device dimensions are dimensions that can be
   * changed by the user through the testbed config yaml. We need to keep a copy of the previous
   * dimensions {@code configAndSharedDeviceDimensions} so that we know which dimensions to remove
   * when there is a change in dimensions. Dimensions that came from other sources should not be
   * removed.
   *
   * <p>First example, we have a change in testbed level dimensions:
   *
   * <p>Previous config:
   *
   * <pre>{@code
   * - name: Testbed
   *   dimensions:
   *     foo: bar
   *   ...
   * }</pre>
   *
   * <p>Updated config:
   *
   * <pre>{@code
   * - name: Testbed
   *   dimensions:
   *     bar: foo
   *   ...
   * }</pre>
   *
   * <p>The dimension {foo: bar} will be removed and {bar: foo} will be added.
   *
   * <p>Second example, we have a change in subdevice shared dimensions.
   *
   * <p>Previous config:
   *
   * <pre>{@code
   * - name: Testbed
   *   devices:
   *     - id: 123
   *       dimensions:
   *         model: pixel
   *         location: ntc
   *     - id: 234
   *       dimensions:
   *         model: pixel
   *   ...
   * }</pre>
   *
   * <p>Updated config:
   *
   * <pre>{@code
   * - name: Testbed
   *   devices:
   *     - id: 123
   *       dimensions:
   *         model: pixel
   *         location: ntc
   *     - id: 345
   *       dimensions:
   *         model: s10
   *         location: ntc
   *   ...
   * }</pre>
   *
   * <p>The dimension {model: pixel} will be removed and {location: ntc} will be added.
   */
  private void refreshConfigAndSharedDeviceDimensions() {
    ImmutableListMultimap<String, String> newDimensions = getNewConfigAndSharedDeviceDimensions();

    // Remove dimensions from previous config and shared device dimensions that are not in the new
    // config and shared device dimensions.
    getDimensions().stream()
        .filter(
            dimension ->
                !NOT_OVERRIDE_DIMENSIONS.contains(dimension.getName())
                    && !newDimensions.containsKey(dimension.getName()))
        .forEach(dimension -> removeDimension(dimension.getName()));

    // Apply config and shared device dimensions to testbed device dimensions.
    newDimensions
        .keySet()
        .forEach(key -> updateDimension(key, newDimensions.get(key).toArray(new String[0])));
  }

  /** Update required dimensions with the required dimensions from the testbed config. */
  private void updateRequiredDimensions() {
    for (Map.Entry<String, String> dimension : getConfig().getRequiredDimensions().entries()) {
      if (!NOT_OVERRIDE_DIMENSIONS.contains(dimension.getKey())) {
        updateRequiredDimension(dimension.getKey(), dimension.getValue());
      }
    }
  }

  /**
   * Updates the device current state as a supported device type.
   *
   * <p>Testbeds need the ability to check if there subdevices are within the correct state as well
   * as exist. Decorators do not present the state of the device, and thus the TestbedDecorator
   * cannot remove testbeds in bad states. To resolve this the testbed is placed into an ABNORMAL
   * state if aliases are wrong to indicate that the testbed exists, but is in a non-expected state.
   */
  private void updateTestbedStateType() throws MobileHarnessException {
    addSupportedDeviceType(getClass().getSimpleName());
    addSupportedDeviceType("MoblyDevice");
    if (containsPoorDeviceType()) {
      addSupportedDeviceType(ABNORMAL_TESTBED_DEVICE_NAME);
    } else {
      addSupportedDeviceType(NORMAL_TESTBED_DEVICE_NAME);
    }
  }

  private boolean containsPoorDeviceType() throws MobileHarnessException {
    for (Device device : managedDevices) {
      if (!device.getDeviceTypes().containsAll(getSubDeviceInfo(device).getDeviceAliasType())) {
        return true;
      }
    }
    return false;
  }

  /**
   * Apply a serialization of the dimensions of every managed subdevices as a single dimension with
   * key {@code SUBDEVICE_DIMENSIONS_KEY}.
   *
   * <p>The value is a {@link SubDeviceDimensions} proto object,serialized to raw byte stream, and
   * encoded to string: <code>
   * "subdevice_dimensions": "
   *   sub_device_dimension {
   *     device_id: "0629cc66344bcd7f"
   *       device_dimension { name: "host_name" value: "foo.mtv.corp.g.com" }
   *       device_dimension { name: "host_ip" value: "172.17.118.148" }
   *       device_dimension { name: "host_os" value: "Linux" }
   *       device_dimension { name: "host_version" value: "4.28.1" }
   *       device_dimension { name: "location_type" value: "not_in_china" }
   *       device_dimension { name: "device_type" value: "IosRealDevice" }
   *   }
   *   sub_device_dimension {
   *     device_id: "HT7391A00066"
   *       device_dimension { name: "host_name" value: "foo.mtv.corp.g.com" }
   *       device_dimension { name: "host_ip" value: "172.17.118.148" }
   *       device_dimension { name: "host_os" value: "Linux" }
   *       device_dimension { name: "host_version" value: "4.28.1" }
   *       device_dimension { name: "location_type" value: "not_in_china" }
   *       device_dimension { name: "device_type" value: "AndroidRealDevice" }
   *   }"
   * </code>
   *
   * <p>To deserialize the String representation, use: <code>
   *     SubDeviceDimensions.parseFrom(Base64.getDecoder().decode(subDeviceDimensions));
   * </code>
   */
  private void applySerializedSubDeviceDimensions() {
    SubDeviceDimensions.Builder subDeviceDimensionsBuilder = SubDeviceDimensions.newBuilder();
    managedDevices.forEach(
        managedDevice -> {
          subDeviceDimensionsBuilder.addSubDeviceDimension(
              SubDeviceDimensions.SubDeviceDimension.newBuilder()
                  .setDeviceId(managedDevice.getDeviceId())
                  .addAllDeviceDimension(managedDevice.getDimensions())
                  .build());
        });
    updateDimension(
        TestbedDeviceSpec.SUBDEVICE_DIMENSIONS_KEY,
        TestbedUtil.encodeSubDeviceDimensions(subDeviceDimensionsBuilder.build()));
  }

  /**
   * Updates the device dimensions and state.
   *
   * <p>Order is important when updating dimensions. Updates subdevice dimensions from the config,
   * then updates the testbed device dimensions. This is so that the shared device dimensions from
   * subdevices that are propagated to the testbed level will be updated to the one in the config.
   */
  private void updateDimensionsAndState() throws MobileHarnessException, InterruptedException {
    updateSubDeviceDeviceTypeDimension();
    updateSubDeviceInfoFromConfig();
    refreshConfigAndSharedDeviceDimensions();
    updateRequiredDimensions();
    updateMoretoDriver();
    applySerializedSubDeviceDimensions();
    addDimension("testbed_name", getConfig().getName());
    addDimension(Name.OS, Value.TESTBED);
    info().deviceTypes().clear();
    updateTestbedStateType();
  }

  /**
   * Update testbed device supported drivers with Moreto drivers to allow allocation of Moreto jobs
   * to this testbed device.
   */
  private void updateMoretoDriver() throws InterruptedException {
    if (managedDevices.stream()
        .anyMatch(device -> device.getDriverTypes().contains(ANDROID_MORETO_DRIVER))) {
      addSupportedDriver(ANDROID_MORETO_DRIVER);
    } else {
      removeSupportedDriver(ANDROID_MORETO_DRIVER);
    }
  }

  /**
   * Retrieves the {@link SubDeviceInfo} for a given sub-{@link Device} or an Optional.empty() if
   * the test bed config does not contain info for the device.
   *
   * @param device the device to look up
   * @return the associated SubDeviceInfo if present otherwise Optional.empty()
   */
  private SubDeviceInfo getSubDeviceInfo(Device device) throws MobileHarnessException {
    SubDeviceKey key = SubDeviceKey.create(device.getDeviceId(), device.getClass());
    SubDeviceInfo info = getConfig().getDevices().get(key);
    if (info == null) {
      // We update the device list to match the list in the underlying config in checkDevice(). This
      // would only happen if a test is triggered before MH has the chance to call checkDevice(). In
      // this case the user should wait until checkDevice() is called and re-run their test.
      throw new MobileHarnessException(
          ExtErrorId.MOBLY_TESTBED_CONFIG_ERROR,
          "Test bed config "
              + getConfig().getName()
              + " does not reference device "
              + device.getDeviceId()
              + ". If you recently changed the devices listed in your test bed config, please wait "
              + "around a minute and try running your test again.");
    }
    return info;
  }

  /**
   * Call a method on each sub device.
   *
   * <p>NOTE: This should only be used for operations that happen before {@link Device#tearDown} is
   * called.
   */
  @VisibleForTesting
  void forEachManagedDevice(SubdeviceConsumer consumer, String methodName)
      throws MobileHarnessException, InterruptedException {
    parallelForEachDevice(managedDevices, convertToCallable(consumer), results -> null, methodName);
  }

  private <T> T forEachManagedDevice(
      SubdeviceCallable<T> callable, Function<List<T>, T> merger, String methodName)
      throws MobileHarnessException, InterruptedException {
    return parallelForEachDevice(managedDevices, callable, merger, methodName);
  }

  private void parallelForEachDevice(
      List<Device> devices, SubdeviceConsumer consumer, String methodName)
      throws MobileHarnessException, InterruptedException {
    parallelForEachDevice(devices, convertToCallable(consumer), results -> null, methodName);
  }

  private <T> T parallelForEachDevice(
      List<Device> devices,
      SubdeviceCallable<T> callable,
      Function<List<T>, T> merger,
      String methodName)
      throws MobileHarnessException, InterruptedException {
    return ConcurrencyUtil.runInParallel(
        devices.stream()
            .map(device -> convertToSubTask(callable, device, methodName))
            .collect(Collectors.toList()),
        MoreExecutors.listeningDecorator(subdeviceExecutor),
        merger);
  }

  private static <T> SubTask<T> convertToSubTask(
      SubdeviceCallable<T> callable, Device device, String methodName) {
    return SubTask.of(
        () -> {
          try {
            return callable.run(device);
          } catch (MobileHarnessException e) {
            throw new com.google.devtools.mobileharness.api.model.error.MobileHarnessException(
                ExtErrorId.MOBLY_TESTBED_SUBDEVICE_CALLABLE_ERROR, e.getMessage(), e);
          }
        },
        String.format("TestbedDevice.%s", methodName),
        "TESTBED_SUBDEVICE",
        device.getDeviceId());
  }

  private static SubdeviceCallable<?> convertToCallable(SubdeviceConsumer consumer) {
    return device -> {
      consumer.run(device);
      return null;
    };
  }

  private static String getTestInfoLogString(TestInfo testInfo) {
    return String.format(
        "TestInfo=(%s, %s)", testInfo.locator().getName(), testInfo.locator().getId());
  }

  @FunctionalInterface
  interface SubdeviceCallable<T> {
    T run(Device device) throws MobileHarnessException, InterruptedException;
  }

  @FunctionalInterface
  interface SubdeviceConsumer {
    void run(Device device) throws MobileHarnessException, InterruptedException;
  }
}
