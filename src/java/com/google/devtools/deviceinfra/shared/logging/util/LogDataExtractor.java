/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.devtools.deviceinfra.shared.logging.util;

import com.google.common.flogger.LogContext;
import com.google.common.flogger.LogSite;
import com.google.common.flogger.LogSites;
import com.google.common.flogger.MetadataKey;
import com.google.common.flogger.backend.LogData;
import com.google.common.flogger.backend.MetadataHandler;
import com.google.common.flogger.backend.MetadataProcessor;
import com.google.common.flogger.backend.system.AbstractLogRecord;
import com.google.common.flogger.context.Tags;
import java.util.Optional;
import java.util.logging.LogRecord;

/**
 * A utility class to allow backend log handling code using the JDK logging libraries to extract
 * additional information from any Flogger generated log records.
 */
public final class LogDataExtractor {
  /**
   * Returns the {@code LogData} instance of a given Flogger generated log record. If the given
   * record was not generated by Flogger, then the empty optional is returned.
   */
  public static Optional<LogData> extractLogData(LogRecord record) {
    if (record instanceof AbstractLogRecord) {
      return Optional.of(((AbstractLogRecord) record).getLogData());
    }
    return Optional.empty();
  }

  /**
   * Returns a log site of a given log record which, for Flogger generated records, will contain
   * class, method and line number information. If the given record was not generated by Flogger,
   * then a synthetic {@code LogSite} is returned containing at least class and method names. If the
   * log record cannot provide basic class or method information then {@link LogSite#INVALID} is
   * returned.
   */
  public static LogSite getLogSite(LogRecord record) {
    if (record instanceof AbstractLogRecord) {
      return ((AbstractLogRecord) record).getLogData().getLogSite();
    }
    // In theory the class and/or method name in a log record can be null...
    if (record.getSourceClassName() != null && record.getSourceMethodName() != null) {
      // This should almost never happen so it's not worth optimizing to avoid extra allocations.
      return LogSites.logSiteFrom(
          new StackTraceElement(
              record.getSourceClassName(),
              record.getSourceMethodName(),
              null,
              LogSite.UNKNOWN_LINE));
    }
    return LogSite.INVALID;
  }

  /**
   * Processes a combined view of the scope and log-site metadata in this processor by invoking the
   * given handler for each distinct metadata key. The handler method invoked depends on whether the
   * key is single valued or repeated.
   *
   * @see MetadataProcessor
   */
  public static <C> void processMetadata(LogRecord record, MetadataHandler<C> handler, C context) {
    if (record instanceof AbstractLogRecord) {
      ((AbstractLogRecord) record).getMetadataProcessor().process(handler, context);
    }
  }

  /**
   * Invokes the given handler for the combined scope and log-site metadata for a specified key. The
   * handler method invoked depends on whether the key is single valued or repeated. If no metadata
   * is present for the given key, the handler is not invoked.
   *
   * @see MetadataProcessor
   */
  public static <C> void handleMetadata(
      LogRecord record, MetadataKey<?> key, MetadataHandler<C> handler, C context) {
    if (record instanceof AbstractLogRecord) {
      ((AbstractLogRecord) record).getMetadataProcessor().handle(key, handler, context);
    }
  }

  /**
   * Returns the unique value for a single valued key, or {@code null} if not present.
   *
   * <p>If you just need the {@link Tags} value of a log record, use {@link #getTags} instead.
   *
   * @throws IllegalArgumentException if passed a repeatable key (even if that key has one value).
   */
  public static <T> T getSingleMetadataValue(LogRecord record, MetadataKey<T> key) {
    if (record instanceof AbstractLogRecord) {
      return ((AbstractLogRecord) record).getMetadataProcessor().getSingleValue(key);
    }
    return null;
  }

  /**
   * Returns the (possible empty) {@link Tags} instance for a log record.
   *
   * <p>Note that {@code Tags} make up only a fraction of the possible context metadata in a log
   * statement, and anyone using only this method to access logging metadata should strongly
   * consider using {@link #processMetadata(LogRecord,MetadataHandler,Object)} instead, which
   * provides a more coherent view of all the available metadata from both the log site and any
   * scoped logging contexts.
   *
   * <p>Since this method never returns {@code null} it cannot be used to distinguish between "log
   * records without tags" and "log records with empty tags". This is deliberate and no code should
   * rely on being able to distiguish these cases.
   */
  // NOTE: At some stage "Tags" will not be added to the log-site metadata and will instead come
  // directly from the scoped logging context (not via the Metadata API at all). At that point
  // LogContext.Key.TAGS can be deleted and this method switched access tags directly.
  public static Tags getTags(LogRecord record) {
    if (record instanceof AbstractLogRecord) {
      Tags tags =
          ((AbstractLogRecord) record).getMetadataProcessor().getSingleValue(LogContext.Key.TAGS);
      if (tags != null) {
        return tags;
      }
    }
    return Tags.empty();
  }

  private LogDataExtractor() {}
}
