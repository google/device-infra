/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.devtools.mobileharness.infra.lab.controller;

import static com.google.devtools.mobileharness.shared.util.time.TimeUtils.isDurationPositive;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ListMultimap;
import com.google.common.flogger.FluentLogger;
import com.google.devtools.mobileharness.api.model.error.MobileHarnessException;
import com.google.devtools.mobileharness.infra.lab.common.dir.DirUtil;
import com.google.devtools.mobileharness.shared.util.base.StrUtil;
import com.google.devtools.mobileharness.shared.util.command.Command;
import com.google.devtools.mobileharness.shared.util.command.CommandExecutor;
import com.google.devtools.mobileharness.shared.util.command.CommandFailureException;
import com.google.devtools.mobileharness.shared.util.file.local.LocalFileUtil;
import com.google.devtools.mobileharness.shared.util.file.local.ResUtil;
import com.google.devtools.mobileharness.shared.util.flags.Flags;
import com.google.devtools.mobileharness.shared.util.path.PathUtil;
import com.google.devtools.mobileharness.shared.util.system.SystemUtil;
import com.google.devtools.mobileharness.shared.util.time.Sleeper;
import com.google.devtools.mobileharness.shared.util.time.TimeUtils;
import com.google.wireless.qa.mobileharness.shared.MobileHarnessLogger;
import com.google.wireless.qa.mobileharness.shared.constant.Dimension;
import com.google.wireless.qa.mobileharness.shared.constant.DirCommon;
import com.google.wireless.qa.mobileharness.shared.constant.ExitCode;
import com.google.wireless.qa.mobileharness.shared.model.job.JobSetting;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Clock;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Handler;

/**
 * Class for cleaning up files generated by lab server.
 *
 * <p>Lab server can generate the following files:
 *
 * <ol>
 *   <li>RECEIVED_FILES: Located under {@link DirUtil#getReceivedDir()}
 *   <li>RUN_FILES: Located under {@link DirUtil#getRunDir()}
 *   <li>PUBLIC_GEN_FILES: Located under {@link DirUtil#getPublicGenDir()}
 *   <li>PRIVATE_GEN_FILES: Located under {@link DirUtil#getPrivateGenDir()}
 *   <li>RES_FILES: Located under {@link ResUtil#getResDir()}
 * </ol>
 *
 * <p>The mechanism of cleaning these files is:
 *
 * <ol>
 *   <li>Removes all directory when lab server starts up: RECEIVED_FILES, RUN_FILES,
 *       PUBLIC_GEN_FILES, PRIVATE_GEN_FILES, RES_FILES
 *   <li>Removes job related files when job finished: RUN_FILES, PUBLIC_GEN_FILES, PRIVATE_GEN_FILES
 *   <li>Periodically clean up: RECEIVED_FILES, RUN_FILES, PUBLIC_GEN_FILES, PRIVATE_GEN_FILES
 * </ol>
 */
public class FileCleaner implements Runnable {
  private static final FluentLogger logger = FluentLogger.forEnclosingClass();

  /** Sleep interval in milliseconds for removing expired files or dirs. */
  private static final Duration REMOVE_FILES_INTERVAL = Duration.ofMillis(200L);

  /** Minimal free disk space. If lower than this, will send out mail alert. */
  private static final int MIN_USABLE_DISK_PERCENTAGE = 20;

  /** The system log directory to monitor. */
  @VisibleForTesting static final String SYSTEM_LOG_DIR = "/var/log";

  /** If size of any files in {@link #SYSTEM_LOG_DIR} is larger than this, will be cleaned up. */
  @VisibleForTesting static final long MAX_SYSTEM_LOG_SIZE = 10L * 1024L * 1024L; // 10 MB

  private static final int MIN_DISK_USABLE_SIZE_MB = 1024;

  private static final int MAX_CONSECUTIVE_FILE_SYSTEM_IO_CHECK_FAILURES = 3;
  private static final int MAX_CONSECUTIVE_FILE_SYSTEM_IO_CHECK_SUCCESSES = 1;

  /** Utility for local file operation. */
  private final LocalFileUtil fileUtil;

  /** Utility for checking zombie files and killing zombie processes. */
  private final SystemUtil systemUtil;

  /** Mockable {@code Sleeper} for putting current thread to sleep. */
  private final Sleeper sleeper;

  /** Mockable {@code Clock} for getting current system time. */
  private final Clock clock;

  private final CommandExecutor commandExecutor;

  /**
   * The directories which needs to be managed by FileCleaner. Managed directories' paths and
   * expired time mapping.
   */
  private final ConcurrentHashMap<String, Duration> managedDirs = new ConcurrentHashMap<>();

  /** The sub directories which should be skipped by FileCleaner for expiration check. */
  private final List<String> skippedSubDirs = new ArrayList<>();

  private int consecutiveFileSystemIoCheckFailures;
  private int consecutiveFileSystemIoCheckSuccesses;

  /** Creates a cleaner for periodically cleaning up the files generated by lab server. */
  public FileCleaner() {
    this(
        new LocalFileUtil(),
        new SystemUtil(),
        Sleeper.defaultSleeper(),
        Clock.systemUTC(),
        new CommandExecutor());
  }

  /** Constructors for unit tests only. */
  @VisibleForTesting
  FileCleaner(
      LocalFileUtil fileUtil,
      SystemUtil systemUtil,
      Sleeper sleeper,
      Clock clock,
      CommandExecutor commandExecutor) {
    this.fileUtil = fileUtil;
    this.systemUtil = systemUtil;
    this.sleeper = sleeper;
    this.clock = clock;
    this.commandExecutor = commandExecutor;
  }

  @Override
  public void run() {
    Handler logHandler = null;

    try {

      String tmpFileDir = DirUtil.getTempDir();
      try {
        // In case there are some legacy read-only files, e.g.: b/27818982.
        if (fileUtil.isFileOrDirExist(tmpFileDir)) {
          fileUtil.grantFileOrDirFullAccessRecursively(tmpFileDir);

          // Removes the lab server tmp dir. This includes: RECEIVED_FILES, RUN_FILES,
          // PRIVATE_GEN_FILES.
          // Note the RES_FILES are removed by {@link
          // com.google.devtools.mobileharness.shared.util.file.local.ResUtil} when lab server
          // starts.
          fileUtil.removeFileOrDir(tmpFileDir);
        }

        // Re-creates the tmp dir and grant it full access. So when switching users, others can
        // remove it.
        fileUtil.prepareDir(tmpFileDir);
        fileUtil.grantFileOrDirFullAccessRecursively(tmpFileDir);
      } catch (MobileHarnessException e) {
        new SystemUtil()
            .exit(
                ExitCode.Shared.FILE_OPERATION_ERROR,
                String.format(
                    "Failed to prepare dir %s. Please make sure you are running as root.",
                    DirUtil.getTempDir()),
                e);
      }

      // Removes the PUBLIC_GEN_DIR.
      String genFileDir = DirUtil.getPublicGenDir();
      if (isDurationPositive(Flags.instance().jobGenFileExpiredTime.getNonNull())) {
        logger.atInfo().log(
            "Skip removing the PUBLIC_GEN_FILES folder %s because flag"
                + " job_gen_file_expired_time is non zero.",
            genFileDir);
      } else {
        try {
          // In case there are some legacy read-only files. e.g.: b/27818982.
          if (fileUtil.isDirExist(genFileDir)) {
            fileUtil.grantFileOrDirFullAccessRecursively(genFileDir);
            fileUtil.removeFileOrDir(genFileDir);
          }
        } catch (MobileHarnessException e) {
          logger.atWarning().withCause(e).log(
              "Failed to remove the Mobile Harness PUBLIC_GEN_FILES folder: %s",
              DirUtil.getPublicGenDir());
        }

        // Re-creates the PUBLIC_GEN_DIR and grants it full access. Otherwise, even the
        // sub-directories and files provide full access, users may still fail to download them
        // via
        // HTTP. See b/12490621.
        try {
          fileUtil.prepareDir(genFileDir);
          fileUtil.grantFileOrDirFullAccessRecursively(genFileDir);
        } catch (MobileHarnessException e) {
          new SystemUtil()
              .exit(
                  ExitCode.Shared.FILE_OPERATION_ERROR,
                  "Failed to prepare the PUBLIC_GEN_FILES folder: " + DirUtil.getPublicGenDir(),
                  e);
        }
      }

      // Remove redundant files mh_container_test_* and mh_res_files_* under
      // /usr/local/google/mobileharness/. See b/151272087.
      try {
        fileUtil.removeFilesOrDirs(DirCommon.getTempDirRoot(), "mh_container_test_.*");
        fileUtil.removeFilesOrDirs(
            DirCommon.getTempDirRoot(), ResUtil.DEFAULT_RES_DIR_NAME + "_.*");
      } catch (MobileHarnessException e) {
        logger.atWarning().withCause(e).log(
            "Failed to remove the Mobile Harness mh_container_test_* and %s_* folder",
            ResUtil.DEFAULT_RES_DIR_NAME);
      }

      // DirUtil.getTempDir() is the {TEST_TMPDIR} in the lab server environment. The TTL of files
      // under this directory is {@code JobSetting.MAX_JOB_TIMEOUT} default.
      managedDirs.putIfAbsent(DirUtil.getTempDir(), JobSetting.MAX_JOB_TIMEOUT);

      // The following directories are some sub directories of DirUtil.getTempDir(). Uses
      // different
      // TTL for different sub directories.
      managedDirs.putIfAbsent(
          DirUtil.getReceivedDir(), Flags.instance().fileExpireTime.getNonNull());
      // The following directories are "job level" directories.
      managedDirs.putIfAbsent(DirUtil.getRunDir(), JobSetting.MAX_JOB_TIMEOUT);
      // The following directories are "test level" directories.
      Duration genFileExpireTime =
          Flags.instance().jobGenFileExpiredTime.getNonNull().compareTo(JobSetting.MAX_TEST_TIMEOUT)
                  > 0
              ? Flags.instance().jobGenFileExpiredTime.getNonNull()
              : JobSetting.MAX_TEST_TIMEOUT;
      managedDirs.putIfAbsent(DirUtil.getPublicGenDir(), genFileExpireTime);
      managedDirs.putIfAbsent(DirUtil.getPrivateGenDir(), genFileExpireTime);

      // Cloud received directory is in the TempDir which should be skipped and managed by
      // cloud file transfer itself.
      // TODO: Align the deleting strategy of Cloud FileTransfer with others.
      skippedSubDirs.add(DirUtil.getCloudReceivedDir());

      while (!Thread.currentThread().isInterrupted()) {
        // Checks file system IO
        try {
          if (Flags.instance().enableFileSystemIoCheck.getNonNull()) {
            checkFileSystemIo();
          }
        } catch (RuntimeException e) {
          logger.atSevere().withCause(e).log("FATAL ERROR when checking file system IO.");
        }

        // Cleans expired files in the managed directories.
        for (Entry<String, Duration> dir : managedDirs.entrySet()) {
          try {
            cleanExpiredFiles(dir.getKey(), dir.getValue().toMillis());
          } catch (MobileHarnessException e) {
            logger.atWarning().withCause(e).log("Failed to check or remove expired files");
          } catch (InterruptedException e) {
            throw e;
          } catch (RuntimeException e) {
            logger.atSevere().withCause(e).log("FATAL ERROR");
          }
        }

        // Cleans system logs.
        try {
          cleanSystemLogs();
        } catch (MobileHarnessException e) {
          logger.atWarning().withCause(e).log("Failed to clean system logs");
        } catch (InterruptedException e) {
          throw e;
        } catch (RuntimeException e) {
          logger.atSevere().withCause(e).log("FATAL ERROR");
        }

        // Cleans zombie files.
        if (Flags.instance().enableZombieFileClean.getNonNull()) {
          try {
            cleanZombieFiles();
          } catch (MobileHarnessException e) {
            logger.atWarning().withCause(e).log("Failed to clean zombie files");
          } catch (RuntimeException e) {
            logger.atSevere().withCause(e).log("FATAL ERROR");
          }
        }

        // Checks disk space.
        try {
          if (Flags.instance().enableDiskCheck.getNonNull()) {
            checkDiskSpace();
          }
        } catch (MobileHarnessException e) {
          logger.atWarning().withCause(e).log("Failed to check disk space");
        } catch (RuntimeException e) {
          logger.atSevere().withCause(e).log("FATAL ERROR");
        }
        sleeper.sleep(Flags.instance().checkFilesInterval.getNonNull());
      }
    } catch (InterruptedException e) {
      logger.atInfo().log("Interrupted");
    } finally {
      MobileHarnessLogger.removeHandler(FileCleaner.class, logHandler);
      if (logHandler != null) {
        logHandler.close();
      }
    }
  }

  /**
   * Adds a new directory which need to be managed by FileCleaner.
   *
   * @return true if the new managed directory is new for FileCleaner.
   */
  public boolean addManagedDir(String newManagedDir, Duration expireTime) {
    return managedDirs.putIfAbsent(newManagedDir, expireTime) == null;
  }

  /**
   * Checks the files and deletes expired ones.
   *
   * @throws MobileHarnessException if failed to check or remove expired files
   */
  @VisibleForTesting
  void cleanExpiredFiles(String dirPath, long expireTimeMs)
      throws MobileHarnessException, InterruptedException {
    if (!fileUtil.getFileOrDir(dirPath).exists()) {
      logger.atInfo().log("Skip cleaning nonexistent directory: %s", dirPath);
      return;
    }
    long threshold = clock.instant().toEpochMilli() - expireTimeMs;
    File[] fileOrDirs = fileUtil.listFilesOrDirs(dirPath);
    if (fileOrDirs.length == 0) {
      logger.atInfo().log("Skip cleaning empty directory :%s", dirPath);
      return;
    }

    Set<String> linkedFiles;
    try {
      linkedFiles = fileUtil.listAllFilesBeenLinked(dirPath);
    } catch (MobileHarnessException e) {
      logger.atWarning().withCause(e).log("Failed to list all files been linked");
      linkedFiles = new HashSet<>();
    }
    int removedFileOrDirCount = 0;
    for (File fileOrDir : fileOrDirs) {
      // Check if the folder or file should be skipped.
      String fileOrDirPath = fileOrDir.getAbsolutePath();
      if (skippedSubDirs.stream().anyMatch(skippedPath -> fileOrDirPath.contains(skippedPath))) {
        continue;
      }
      long lastModified = fileOrDir.lastModified();
      // Clean only when the file is too old and there is no link in temp dir to this file.
      if (lastModified < threshold) {
        // Clean only there is no link in temp dir to this file.
        if (!linkedFiles.contains(fileOrDirPath)) {
          removeFileOrDir(fileOrDir);
          removedFileOrDirCount++;
        }
      }
    }
    if (removedFileOrDirCount == 0) {
      logger.atInfo().log(
          "Skip cleaning directory(%d subfiles) because no file older than %d minutes: %s",
          fileOrDirs.length,
          TimeUnit.MINUTES.convert(expireTimeMs, TimeUnit.MILLISECONDS),
          dirPath);
    } else {
      logger.atInfo().log(
          "Removed %d files older than %d minutes from directory(%s subfiles): %s",
          removedFileOrDirCount,
          TimeUnit.MINUTES.convert(expireTimeMs, TimeUnit.MILLISECONDS),
          fileOrDirs.length,
          dirPath);
    }
    logger.atInfo().log("%s: %s", dirPath, fileUtil.getFileOrDirHumanReadableSize(dirPath));
  }

  /**
   * Cleans system logs:
   *
   * <ul>
   *   <li>Deletes log files like "foo.gz", "foo.old", "foo.1".
   *   <li>Empties log files larger than 10MB.
   * </ul>
   */
  @VisibleForTesting
  void cleanSystemLogs() throws MobileHarnessException, InterruptedException {
    if (!fileUtil.isFileExist(SYSTEM_LOG_DIR)) {
      logger.atInfo().log("Skip cleaning nonexistent system log directory: %s", SYSTEM_LOG_DIR);
      return;
    }
    for (String filePath : fileUtil.listFilePaths(SYSTEM_LOG_DIR, /* recursively= */ false)) {
      try {
        long fileSize = fileUtil.getFileOrDirSize(filePath);
        String fileName = PathUtil.basename(filePath).toLowerCase(Locale.ROOT);
        if (fileName.endsWith(".gz")
            || fileName.endsWith(".old")
            || /* File extension name is number: */ fileName.matches(".+\\.\\d+$")) {
          logger.atInfo().log(
              "Remove log file %s (%s)", filePath, StrUtil.getHumanReadableSize(fileSize));
          fileUtil.grantFileOrDirFullAccess(filePath);
          fileUtil.removeFileOrDir(filePath);
        } else if (fileName.contains("log") && fileSize >= MAX_SYSTEM_LOG_SIZE) {
          logger.atInfo().log(
              "Clean log file %s (%s): %n%s%n...",
              filePath, StrUtil.getHumanReadableSize(fileSize), fileUtil.readFileHead(filePath));
          fileUtil.writeToFile(filePath, "");
        }
      } catch (MobileHarnessException e) {
        logger.atWarning().log("Failed to check system log %s: %s", filePath, e.getMessage());
      }
    }
  }

  /** Cleans the deleted files which haven't freed the disk space. */
  @VisibleForTesting
  void cleanZombieFiles() throws MobileHarnessException, InterruptedException {
    // Example output:
    // COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME
    // java 15965 root 7u REG 252,1 2998001950 800534 /var/...
    String openFiles;
    try {
      Command lsofCommand =
          Command.of(
                  "bash",
                  "-c",
                  // Runs lsof to list all deleted files (+L1) and selects lines which contain one
                  // of two substrings.
                  String.format(
                      "lsof +L1 -Ki | awk '$0 ~ \"%s\" || $0 ~ \"%s\" {print $0}'",
                      PathUtil.join(DirCommon.getPublicDirRoot(), DirUtil.DIR_PREFIX),
                      DirCommon.getTempDirRoot()))
              .redirectStderr(false);
      openFiles = commandExecutor.exec(lsofCommand).stdoutWithoutTrailingLineTerminator();
    } catch (CommandFailureException e) {
      // When running in a Docker container, we don't have "lsof".
      logger.atInfo().log("Skip cleaning zombie files: %s", e.getMessage());
      return;
    }

    // {ProcessId, FileInfo} mapping.
    ListMultimap<Integer, String> zombieFiles = ArrayListMultimap.create();
    for (String openFile : Splitter.on('\n').split(openFiles)) {
      logger.atInfo().log("Zombie file: %s", openFile);
      List<String> words = Splitter.onPattern("\\s+").splitToList(openFile);
      String errMsg = "Failed to parse zombie file info: " + openFile;
      if (words.size() < 2) {
        logger.atWarning().log("%s", errMsg);
      } else {
        try {
          zombieFiles.put(Integer.valueOf(words.get(1)), openFile);
        } catch (NumberFormatException e) {
          logger.atWarning().withCause(e).log("%s", errMsg);
        }
      }
    }

    for (int processId : zombieFiles.keySet()) {
      String processInfo = systemUtil.getProcessInfo(processId);
      if (!processInfo.isEmpty()) {
        String msg =
            "Found zombie process: \n"
                + processInfo
                + "\n\n"
                + "Related zombie files:\nCOMMAND\tPID\tUSER\tFD\tTYPE\tDEVICE\tSIZE/OFF\tNODE\t"
                + "NAME\n"
                + Joiner.on("\n").join(zombieFiles.get(processId));
        logger.atInfo().log("%s", msg);

        // TODO: Analyzes lab logs and adds more zombie process killing rules.
        boolean isScreenCast = processInfo.contains("screencast");
        // For safety, only kills the screencast processes which is a known issue.
        if (isScreenCast) {
          try {
            logger.atInfo().log("Kill zombie screencast process: %d", processId);
            systemUtil.killProcess(processId);
          } catch (MobileHarnessException e) {
            logger.atWarning().log(
                "Failed to kill zombie screencast process %d: %s", processId, e.getMessage());
          }
        }
      }
    }
  }

  /**
   * Checks the usable disk space of {@link DirCommon#getPublicDirRoot()} and {@link
   * DirCommon#getTempDirRoot()} and the root partitions. If {@link DirCommon#getTempDirRoot()}
   * usable size is lower than {@link #MIN_DISK_USABLE_SIZE_MB}, all devices will mark as PREPPING.
   */
  @VisibleForTesting
  void checkDiskSpace() throws MobileHarnessException {
    List<File> dirs = new ArrayList<>();
    for (String dirPath :
        ImmutableList.of(DirCommon.getPublicDirRoot(), DirCommon.getTempDirRoot())) {
      if (!fileUtil.getFileOrDir(dirPath).exists()) {
        logger.atInfo().log("Skip checking nonexistent directory: %s", dirPath);
      } else {
        dirs.add(fileUtil.checkDir(dirPath));
      }
    }
    Collections.addAll(dirs, File.listRoots());

    for (File dir : dirs) {
      long usableDiskBytes = dir.getUsableSpace();
      long totalDiskBytes = dir.getTotalSpace();
      int usableDiskPercentage =
          totalDiskBytes == 0 ? 0 : (int) (usableDiskBytes * 100 / totalDiskBytes);
      String message =
          usableDiskPercentage
              + "%("
              + StrUtil.getHumanReadableSize(usableDiskBytes)
              + ") usable disk space for "
              + dir.getPath();

      if (usableDiskPercentage < MIN_USABLE_DISK_PERCENTAGE) {
        logger.atWarning().log("%s", message);
      } else {
        logger.atInfo().log("%s", message);
      }
      if (dir.getAbsolutePath().equals(DirCommon.getTempDirRoot())) {
        // Add alert_lab_disk_usable_size to lab dimension, then DM will mark all devices as
        // PREPPING.
        if ((usableDiskBytes >> 20) < MIN_DISK_USABLE_SIZE_MB) {
          LabDimensionManager.getInstance()
              .getSupportedLocalDimensions()
              .replace(
                  Dimension.Name.ALERT_LAB_DISK_USABLE_SIZE,
                  ImmutableList.of(String.format("%dMB", usableDiskBytes >> 20)));
        } else {
          LabDimensionManager.getInstance()
              .getSupportedLocalDimensions()
              .remove(Dimension.Name.ALERT_LAB_DISK_USABLE_SIZE);
        }
      }
    }
  }

  @VisibleForTesting
  void checkFileSystemIo() {
    String tempDirRoot = DirCommon.getTempDirRoot();
    if (!fileUtil.isFileOrDirExist(tempDirRoot)) {
      logger.atInfo().log(
          "Temp dir root [%s] doesn't exist, skip checking file system IO", tempDirRoot);
      return;
    }

    try {
      deleteAndCreateDummyFile(tempDirRoot);
      consecutiveFileSystemIoCheckFailures = 0;
      consecutiveFileSystemIoCheckSuccesses++;
      if (consecutiveFileSystemIoCheckSuccesses >= MAX_CONSECUTIVE_FILE_SYSTEM_IO_CHECK_SUCCESSES) {
        LabDimensionManager.getInstance()
            .getSupportedLocalDimensions()
            .remove(Dimension.Name.LAB_FILE_SYSTEM_IO_ERROR);
      }
    } catch (IOException e) {
      consecutiveFileSystemIoCheckSuccesses = 0;
      consecutiveFileSystemIoCheckFailures++;
      if (consecutiveFileSystemIoCheckFailures >= MAX_CONSECUTIVE_FILE_SYSTEM_IO_CHECK_FAILURES) {
        LabDimensionManager.getInstance()
            .getSupportedLocalDimensions()
            .replace(Dimension.Name.LAB_FILE_SYSTEM_IO_ERROR, ImmutableList.of("true"));
      }
      logger.atWarning().withCause(e).log("Failed to modify files in dir: %s", tempDirRoot);
    }
  }

  @VisibleForTesting
  void deleteAndCreateDummyFile(String dir) throws IOException {
    Path dummyFile = Path.of(dir, "check_fs_io_dummy_file");
    Files.deleteIfExists(dummyFile);
    dummyFile.toFile().createNewFile();
  }

  /** Removes the given file or dir. */
  private void removeFileOrDir(File fileOrDir) throws MobileHarnessException, InterruptedException {
    String path = fileOrDir.getAbsolutePath();
    logger.atInfo().log(
        "Remove %s [%s]. Last modified: %s",
        (fileOrDir.isFile() ? "file" : "dir"),
        path,
        TimeUtils.toDateString(Instant.ofEpochMilli(fileOrDir.lastModified())));
    fileUtil.grantFileOrDirFullAccessRecursively(path); // for real-only files: b/27818982
    fileUtil.removeFileOrDir(path);
    // A large sequence of I/O operations may be very heavy. Sleeps a short while to reduce
    // system load.
    sleeper.sleep(REMOVE_FILES_INTERVAL);
  }
}
