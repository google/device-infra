/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

package devtools.mobileharness.fe.v6.service.proto.host;

import "google/protobuf/timestamp.proto";
import "src/devtools/mobileharness/fe/v6/service/proto/device/device_resources.proto";

option java_package = "com.google.devtools.mobileharness.fe.v6.service.proto.host";
option java_multiple_files = true;
option java_outer_classname = "HostResourcesProto";

// Represents the comprehensive data required to render the Host Detail Page's
// overview section.
message HostOverview {
  string host_name = 1;
  string ip = 2;
  // The display names for the lab type, e.g., ["Satellite Lab", "ATE Lab"].
  repeated string lab_type_display_names = 3;
  // Lab server process information.
  LabServerInfo lab_server = 4;
  // Daemon server process information.
  DaemonServerInfo daemon_server = 5;
  // Host-level properties.
  map<string, string> properties = 6;
  // OS of the host machine, e.g., "gLinux", "macOS".
  string os = 7;
}

// Host-level connectivity status with OmniLab master.
// FE will map State to icon/color: RUNNING->green/check_circle,
// MISSING->red/error
message HostConnectivityStatus {
  enum State {
    STATE_UNSPECIFIED = 0;
    RUNNING = 1;
    MISSING = 2;
    UNKNOWN = 3;
  }
  // The semantic state of connectivity.
  State state = 1;
  // The text to display for this state, e.g., "Running", "Missing".
  string title = 2;
  // Timestamp of when host was first detected as missing.
  // Only present if state = MISSING.
  google.protobuf.Timestamp missing_start_time = 3;
  // Tooltip text generated by backend based on state.
  string tooltip = 4;
}

// Lab server process information.
// FE will map ActivityState to icon/color/spinning per state:
// STARTED->green/check, STARTED_BUT_DISCONNECTED->yellow/warning,
// STARTING->blue/sync+spin, etc.
message LabServerInfo {
  enum ActivityState {
    ACTIVITY_STATE_UNSPECIFIED = 0;
    STARTED = 1;
    STARTED_BUT_DISCONNECTED = 2;
    STARTING = 3;
    ERROR = 4;
    DRAINING = 5;
    DRAINED = 6;
    STOPPING = 7;
    STOPPED = 8;
    UNKNOWN = 9;
  }
  message Activity {
    // The semantic state of lab server activity.
    ActivityState state = 1;
    // The text to display for this state, e.g., "Started", "Stopping".
    string title = 2;
    // Tooltip text generated by backend based on state.
    string tooltip = 3;
  }
  // Host connectivity with OmniLab master.
  HostConnectivityStatus connectivity = 1;
  // Activity is optional; it will be absent if release_status is null (e.g.
  // Core Labs)
  Activity activity = 2;
  string version = 3;
  string pass_through_flags = 4;
}

// Daemon server process information.
// FE will map State to icon/color: RUNNING->green/check_circle,
// MISSING->red/error
message DaemonServerInfo {
  enum State {
    STATE_UNSPECIFIED = 0;
    RUNNING = 1;
    MISSING = 2;
    UNKNOWN = 3;
  }
  message Status {
    // The semantic state of daemon server.
    State state = 1;
    // The text to display for this state, e.g., "Running", "Missing".
    string title = 2;
    // Timestamp of when daemon was first detected as missing.
    // Only present if state = MISSING.
    google.protobuf.Timestamp missing_start_time = 3;
    // Tooltip text generated by backend based on state.
    string tooltip = 4;
  }
  Status status = 1;
  string version = 2;
}

// Semantic state of the device health.
// Frontend uses this to determine icon and color.
message DeviceHealthState {
  // The semantic state used by FE to determine styling (icon/color).
  device.HealthState health = 1;
  // The display text for the state, e.g., "In Service", "Out of Service".
  string title = 2;
  // Tooltip text explaining the current health state.
  string tooltip = 3;
}

// A summary of a device connected to the host, for display in the device list.
message DeviceSummary {
  string id = 1;
  DeviceHealthState health_state = 2;
  repeated device.DeviceType types = 3;
  device.HealthAndActivityInfo.DeviceStatus device_status = 4;
  string label = 5;
  // TODO: Consider if we need to display more complex form of
  // required dimensions. The type of `required_dims` may need to update.
  string required_dims = 6;
  string model = 7;
  string version = 8;
  repeated device.SubDeviceInfo sub_devices = 9;
  // Optional parent device ID (e.g. for sub-devices belonging to a testbed).
  string parent_device_id = 10;
}

// Types of proxy supported by devices.
enum DeviceProxyType {
  DEVICE_PROXY_TYPE_UNSPECIFIED = 0;
  ADB_AND_VIDEO = 1;
  ADB_ONLY = 2;
  USB_IP = 3;
  SSH = 4;
  VIDEO = 5;
}

// Reason code for a device being ineligible for remote control.
enum IneligibilityReasonCode {
  INELIGIBILITY_REASON_CODE_UNSPECIFIED = 0;
  // User lacks permission for the device.
  PERMISSION_DENIED = 1;
  // Device state is not IDLE (e.g., BUSY, MISSING).
  DEVICE_NOT_IDLE = 2;
  // Device type is not supported (e.g., FailedDevice, AbnormalTestbedDevice, or
  // non-AndroidRealDevice in multi-selection mode).
  DEVICE_TYPE_NOT_SUPPORTED = 3;
  // Host OS is MacOS.
  HOST_OS_NOT_SUPPORTED = 4;
  // Device does not support AcidRemoteDriver.
  ACID_NOT_SUPPORTED = 5;
}

// Options for creating a remote control session.
message SessionOptions {
  // The common proxy types for all devices.
  repeated DeviceProxyType common_proxy_types = 1;
  // The common run as candidates for all devices.
  repeated string common_run_as_candidates = 2;
  // The max duration hours for all devices.
  // If the dimension pool value is shared then the value is 3 hours else 12
  // hours.
  int32 max_duration_hours = 3;
}

// The overall verdict dictating the frontend flow.
enum EligibilityStatus {
  // Default value.
  ELIGIBILITY_STATUS_UNSPECIFIED = 0;
  // All devices are eligible and have a common proxy.
  // If the user has partial permission, the dialog will show the permission
  // denied device card and allow the user to proceed.
  READY = 1;
  // Some selected devices are not eligible(e.g. status is busy, missing; no
  // acid support; host OS is MacOS; etc).
  BLOCK_DEVICES_INELIGIBLE = 2;
  // All devices are eligible individually, but for multiple devices, they
  // share no common proxy type, or for a single device, it has no supported
  // proxy type.
  BLOCK_NO_COMMON_PROXY = 3;
  // Permission is denied for all selected devices.
  BLOCK_ALL_PERMISSION_DENIED = 4;
}

// The eligibility result for a single device.
message DeviceEligibilityResult {
  string device_id = 1;
  // Whether this specific device can be remotely controlled.
  bool is_eligible = 2;

  message IneligibilityReason {
    IneligibilityReasonCode code = 1;
    string message = 2;
  }
  // Detailed reason if the device is ineligible.
  IneligibilityReason ineligibility_reason = 3;

  // Supported proxy types for this device.
  repeated DeviceProxyType supported_proxy_types = 4;

  // Candidates for 'Run As' for this device.
  repeated string run_as_candidates = 5;

  message SubDeviceEligibilityResult {
    string device_id = 1;
    bool is_eligible = 2;
    IneligibilityReason ineligibility_reason = 3;
  }
  // If the device is a composite device (e.g. testbed), this field contains
  // eligibility details for its sub-devices.
  repeated SubDeviceEligibilityResult sub_device_results = 6;
}

// Response for remote control eligibility check.
message CheckRemoteControlEligibilityResponse {
  // The overall verdict dictating the frontend flow.
  EligibilityStatus status = 1;
  // Consolidated list of results for ALL requested devices.
  // Always populated.
  repeated DeviceEligibilityResult results = 2;
  // Session options derived from the intersection of all ELIGIBLE devices.
  // Present only if status is 'READY'.
  SessionOptions session_options = 3;
}

// Flash options for remote control.
message FlashOptions {
  string branch = 1;
  string build_id = 2;
  string target = 3;
  repeated string sub_device_ids = 4;
}

// Configuration for a single device in a remote control request.
message RemoteControlDeviceConfig {
  string device_id = 1;
  string run_as = 2;
  // Optional parent device ID (e.g. for sub-devices belonging to a testbed).
  string parent_device_id = 3;
}

// Response containing results of remote control session startup.
message RemoteControlDevicesResponse {
  message SessionResult {
    string device_id = 1;
    string session_url = 2;
    string error_message = 3;
  }
  repeated SessionResult sessions = 1;
}
