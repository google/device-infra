/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

edition = "2023";

package mobileharness.infra.master.central;

import "src/devtools/mobileharness/api/model/proto/device.proto";
import "src/devtools/mobileharness/api/model/proto/test.proto";
import "src/devtools/mobileharness/infra/master/central/proto/quota.proto";

option features.field_presence = IMPLICIT;
option java_package = "com.google.devtools.mobileharness.infra.master.central.proto";
option java_outer_classname = "Test";

// Defines the type of allocation workflow to use for the test.
enum AllocationType {
  ALLOCATION_TYPE_UNSPECIFIED = 0;

  // The traditional, Omnilab Scheduler-only allocation workflow.
  TRADITIONAL = 1;

  // A test that requires allocation from both Scheduke and the Omnilab
  // Scheduler.
  HYBRID_CHROME_OS = 2;
}

// Defines the execution mode for tests that require multiple allocations.
enum AllocationParallelismMode {
  ALLOCATION_PARALLELISM_MODE_UNSPECIFIED = 0;

  // Allocations are performed sequentially. For HYBRID_CHROME_OS, this means
  // allocating from Scheduke first, and only after success, allocating from
  // the Omnilab Scheduler.
  ALLOCATION_PARALLELISM_MODE_SERIAL = 1;

  // Allocations are performed in parallel. For HYBRID_CHROME_OS, requests are
  // sent to both Scheduke and the Omnilab Scheduler concurrently. The workflow
  // proceeds only after both have succeeded.
  ALLOCATION_PARALLELISM_MODE_PARALLEL = 2;
}

// Describes the backend mechanism used to process the allocation workflow.
enum AllocationExecutionMechanism {
  ALLOCATION_EXECUTION_MECHANISM_UNSPECIFIED = 0;

  // The legacy polling mechanism.
  ALLOCATION_EXECUTION_MECHANISM_POLLING = 1;

  // The new asynchronous, Spanner Queue-based orchestration mechanism.
  ALLOCATION_EXECUTION_MECHANISM_QUEUE_ORCHESTRATOR = 2;
}

// Tracks the granular state of the allocation workflow.
enum AllocationWorkflowStatus {
  ALLOCATION_WORKFLOW_STATUS_UNSPECIFIED = 0;

  // The request has been accepted and is waiting for orchestration.
  NEW = 1;

  // Waiting for Omnilab allocation to be completed.
  PENDING_OMNILAB = 2;

  // All required device allocations have successfully completed.
  ALLOCATED = 3;

  // The allocation workflow failed at one of the steps.
  FAILED = 4;

  // Waiting for Scheduke allocation to be completed.
  // This status is only used in HYBRID_CHROME_OS allocation.
  PENDING_SCHEDUKE = 5;

  // Scheduke allocation succeeded, waiting for Omnilab allocation to start.
  // This status is only used in HYBRID_CHROME_OS allocation.
  READY_FOR_OMNILAB = 6;
}

// Contains all intermediate data generated during the allocation workflow.
message AllocationWorkflowContext {
  // Information related to the Omnilab Scheduler allocation step.
  message OmnilabContext {
    // The scheduler id returned by the Omnilab Scheduler after submitting an
    // allocation request.
    string scheduler_id = 1;

    // The client id generated by Master.
    string client_id = 2;

    // The final device information returned by the Omnilab Scheduler upon
    // successful allocation.
    repeated .mobileharness.api.model.DeviceLocator allocated_device_locator =
        3;
  }

  // Information related to the Scheduke allocation step.
  message SchedukeContext {
    // The request ID returned by Scheduke after submitting an allocation
    // request.
    string scheduke_id = 1;

    // The allocation id returned by Scheduke, which is used for deallocation.
    string allocation_id = 2;

    // The final device information returned by Scheduke upon successful
    // allocation.
    repeated .mobileharness.api.model.DeviceLocator allocated_device_locator =
        3;

    // The network zone of the device leased from Scheduke.
    // This is used to ensure that the Omnilab executor is allocated in the same
    // network zone.
    string network_zone = 4;
  }

  OmnilabContext omnilab_context = 1;
  SchedukeContext scheduke_context = 2;
}

// Contains information about a failure in the allocation workflow.
message AllocationWorkflowFailure {
  // A detailed error message for debugging.
  string reason = 1;
}

enum TestAllocationLatencyType {
  UNKNOWN = 0;

  // The test is pending before the device becomes IDLE.
  TEST_WAIT_FOR_DEVICE = 1;

  // The device is IDLE before the test comes.
  DEVICE_WAIT_FOR_TEST = 2;
}

message TestProfile {
  // Empty but can be extended.
}

// NEXT ID TO USE: 18
message TestCondition {
  // Required:
  .mobileharness.api.model.TestResult result = 1;

  // Required:
  .mobileharness.api.model.TestStatus status = 2;

  // Optional: the allocated devices, if the test has successfully allocated
  // any device. This info will be preserved after the test is finished.
  repeated .mobileharness.api.model.DeviceLocator allocated_device_locator = 3;

  // Required: When the test is firstly added, or reopened to Master. We use
  // this time to calculate the scheduler latency when this test gets an
  // allocation. See b/71722259.
  int64 create_time_ms = 4;

  // Optional: Allocation latency if the test has successfully allocated any
  // device. Calculation method: http://b/71722259#comment3.
  int64 allocation_latency_ms = 5;

  // Optional: Allocation latency type, for understanding the allocation latency
  // under different situations.
  TestAllocationLatencyType allocation_latency_type = 6;

  // Optional: When the test is added to the Master.
  int64 start_time_ms = 7;

  // Optional: When the test is completed.
  int64 end_time_ms = 8;

  // Optional: Duration for how long this test is suspended for quota issues.
  int64 suspended_duration_time_ms = 10;

  // Optional: The quota control result of this test. Only meaningful for shared
  // lab traffic.
  QuotaResult quota_result = 11;

  // =================================================================
  // == NEW FIELDS FOR ASYNCHRONOUS WORKFLOW ORCHESTRATION ==
  // =================================================================

  // Defines the execution mechanism for this test's allocation workflow.
  AllocationExecutionMechanism execution_mechanism = 12;

  // Defines which workflow to execute for this test's allocation.
  AllocationType allocation_type = 13;

  // Tracks the detailed state of the multi-step allocation process.
  AllocationWorkflowStatus allocation_workflow_status = 14;

  // Stores all intermediate data from the allocation process, such as
  // request IDs and partial results.
  AllocationWorkflowContext allocation_workflow_context = 15;

  // If allocation_workflow_status is FAILED, this field should contain details
  // about the failure.
  AllocationWorkflowFailure allocation_workflow_failure = 16;

  // Defines the execution mode (ALLOCATION_PARALLELISM_MODE_SERIAL or
  // ALLOCATION_PARALLELISM_MODE_PARALLEL) for tests that require multiple
  // device allocations.
  AllocationParallelismMode allocation_mode = 17;

  reserved 9;
}
